import numpy as np
import matplotlib.pyplot as plt
import h5py 
import argparse
import matplotlib.cm as cm 
import sys 
from scaling_plotter import * # only used for doing scaling collapses near critical points

plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.serif'] = ['Computer Modern Roman'] + plt.rcParams['font.serif']
pi = np.pi 

### helper functions ### 

# shortest distance between two points on a circle: 
def circ_distance(i,j,L): 
    direct_distance = abs(i - j)    
    wrap_distance = L - direct_distance    
    return min(direct_distance, wrap_distance)

# load data from h5 files 
def loaddata(fin): 
    print("loading data from: ",fin)
    with h5py.File(fin, "r") as f:
        key_list = [key for key in f.keys() if not key.startswith("_")] # saving dictionaries to jld2 files can sometimes cause the creation of additional keys describing the data structure that we don't care about
        data_dict = dict.fromkeys(key_list)
        for key in key_list:
            data_dict[key] = f[key][()]  

    return data_dict 

parser = argparse.ArgumentParser() 
parser.add_argument('-fin',nargs='+') # just give the file stem 
parser.add_argument('-save',default='no') # just give the file stem 

parser.add_argument('-trel_stats',action='store_true') # if true, plots histograms of relaxation times 
parser.add_argument('-expfit',action='store_true') # fit correlations to an exponentially decaying function (instead of polynomial)

parser.add_argument('-interactive',action='store_true') # if true, does interactive finite size scaling stuff 
parser.add_argument('-tune',default='pc') # parameter to tune during interactive fitting 
parser.add_argument('-plot_hamming',action='store_true') # if true, plots the statistics of hamming weights seen in the simulation 
parser.add_argument('-plot_corrs',action='store_true') # if true, plots correlation functions 
parser.add_argument('-corr_image_space',action='store_true') # if true, plots a 2d image of equal-time spatial correlators (at floquet times by default)
parser.add_argument('-corr_image_time',action='store_true') # if true, plots a 2d image of temporal correlators at zero spatial separation (at system center by default)
parser.add_argument('-dw_stats',action='store_true') # if true, plots domain wall statistics data 
parser.add_argument('-plt',default='chi') # if not interactive and none of the above 3 options are true, will make a static plot of the thermodynamic quantity specified by this argument. one of ['bind' 'chi' 'mag']. will attempt to scale this data unless args.raw is true. if interactive, plt must either be chi or mag. 
parser.add_argument('-raw',action='store_true') # if true, plots raw data (instead of scaling it)

parser.add_argument('-change_xscale',action='store_true') # flips the x axis scale from linear to log (or vice versa, depending on the default)
parser.add_argument('-change_yscale',action='store_true') # as above but for y axis 
args = parser.parse_args() 

### aesthetics ### 
cmap = cm.coolwarm
ms = 7 # marker size 
plotsize = 3.5 # size of plots (in.)
lw = 1.2 # line width 
legend_title_fontsize = 13.5; legend_fontsize = 12 

### load data ### 
fins = args.fin   
data = np.zeros(len(fins),dtype=object)
for (f,fin) in enumerate(fins): 
    data[f] = loaddata(fin)

mode = data[0]["mode"].decode('utf-8'); model = data[0]["model"].decode('utf-8'); dimension = 2 if ("2drep" in mode or "tc" in mode) else 1

### set up plots ### 
plot_thermo = (not (args.plot_hamming or args.plot_corrs or args.dw_stats)) and mode == "stats" # if true, plots thermo quantities (magnetization, susceptibility, etc.)
if not plot_thermo: # if plot_thermo, plot will be generated by scaling_plotter.py 
    nplots = 1 if not args.interactive else 2
    fig,ax = plt.subplots(1,nplots,figsize=(plotsize*nplots,plotsize))
    if nplots > 1: 
        plt.subplots_adjust(wspace=.35)
        for a in ax: 
            a.minorticks_off()
    else: 
        ax.minorticks_off()


### time-dependence of logical fidelity ### 
if mode == "Ft": 
    for f in range(len(fins)): 
        col = cmap((f+1)/len(fins))
        bias = data[f]["bias"]
        Fs = data[f]["Fs"].T # fidelities
        l = data[f]["l"]; L = data[f]["L"]
        ps = data[f]["ps"]
        mp = -1 #int(round(len(ps)/2)) # what point of the data to match when curve fitting 
        inds = np.where(Fs != 1000)[0] # evil 
        xs = ps[inds]
        ys = Fs[inds,-1] # final (latest-time) values of fidelities 

        ax.plot(xs,ys,ls='-' if f == 0 else '-',color=col,mec='k',lw=lw,marker='o',ms=ms,label=r'${%d}$'%(l+1))
        pc = data[f]["pc"]
        ts = ps/pc-1 

    titlestring = r''
    if "tc" in model: 
        if data[f]["gadgetnoise"]: 
            titlestring = r"${\rm gadget\, noise}$"
    else: 
        titlestring = r'$\eta = %d$'%bias 
        if data[f]["gadgetnoise"]: 
            titlestring = titlestring + r"$\,\,|\,\,{\rm (gadget\, noise)}$"
    ax.set_title(titlestring)
    ax.set(xlabel=r'$p$',ylabel=r"$F$")
    ax.legend(title=r'$\log_3(L)$',title_fontsize=legend_title_fontsize,fontsize=legend_fontsize)

    if args.change_xscale: 
        ax.set_xscale('log')
    if args.change_yscale: 
        ax.set_yscale('log')

### relaxation times ### 
elif mode == "trel": 
    for f in range(len(fins)): 
        col = cmap((f+1)/len(fins))
        L = data[f]["L"]; l = data[f]["l"]; gadgetnoise = data[f]["gadgetnoise"]
        trels = data[f]["avg_trels"].T # in units of actual circuit depth time (viz. not measured in floquet periods)
        depth = data[f]["depth"].T 
        xs = data[f]["ps"].T 
        depth_factor = depth#**0 # divides relaxation times by this factor 
        ys = trels / depth_factor 
        rawpow = np.polyfit(np.log(xs),np.log(ys),1)[0]
        power = np.round(rawpow) # nearest integer power that gives best fit 
        n = 3 if "5bit" not in model else 5
        wirepower = -L**(np.log(2)/np.log(n)) # the power expected within the wire noise model for tsirelson with n-bit rep code 
        mp = 1 # int(round(len(xs)/2)) # point where the data is matched; 1 gives the smallest value of p 

        # plot a histogram of the relaxation times 
        if args.trel_stats: 
            full_trels = data[f]["full_trels"].T 
            pind_stats = 0 # the index of the value of p that we want the histogram for 
            ax.hist(full_trels[pind_stats,:],color=col)
            ax.set(xlabel=r'$t_{\rm rel}$')

        # plot trel vs p for different system sizes 
        else: 
            plot_errorbars = False 
            if plot_errorbars: 
                full_trels = data[f]["trels"].T 
                ax.errorbar(np.log(1/xs),ys, yerr=np.std(full_trels,axis=1), fmt='', ecolor='k', elinewidth=1, capsize=1, capthick=1,color=col,mec='k',lw=1.2,marker='o',ms=7,label=r'$l=%d$'%(l)) 
            else: 
                ax.plot(np.log(1/xs),ys,color=col,mec='k',lw=1.2,marker='o',ms=7,label=r'$l=%d$'%(l)) 

            plot_crossover = False 
            if model == "tc": # can have some weird scaling, so plot the power law
                if l == 1 and plot_crossover: # show the crossover between different scaling regimes 
                    ax.plot(np.log(1/xs),(xs/xs[0])**(-2) * ys[0],ls='--',color=col,lw=2.5,label=r'$%d$'%(2)) # fit to the form expected 
                    ax.plot(np.log(1/xs),(xs/xs[-1])**(-3) * ys[-1],ls='-.',color=col,lw=2.5,label=r'$%d$'%(3)) # fit to the form expected 
                else: 
                    ax.plot(np.log(1/xs),(xs/xs[mp])**(power) * ys[mp],ls='--',color=col,lw=2.5,label=r'$p^{%d}$'%(power)) # best power law fit  

            else: # plot the expected threshold power 
                ax.plot(np.log(1/xs),(xs/xs[mp])**(wirepower) * ys[mp],ls='--',color=col,lw=2.5) # fit to the form expected 

            if args.change_xscale: 
                ax.set_xscale('log')        
            if not args.change_yscale: 
                ax.set_yscale('log')

            ax.set(xlabel=r'$\ln(1/p)$',ylabel=r'$t_{\rm rel}^{(l)}$' if depth_factor == 1 else r'$t_{\rm rel}^{(l)} / T_l$')

        ax.legend(title=r'$\log_3(L)$',title_fontsize=legend_title_fontsize,fontsize=legend_fontsize)
        ax.legend(fontsize=legend_fontsize)#,loc='lower right')
        # ax.legend(fontsize=legend_fontsize)
        if not ("twodmaj" in model or "factored_tc" in model):
            ax.set_title(r'${\rm %s}\,\,|\, \,\eta = %d$'%(model,data[f]["bias"]))

        if model == "rep":
            modelstring = r"{\rm rep.\, code}"
            titlestring = r'$%s\,\,|\, \,\eta = %d$'%(modelstring,data[f]["bias"])
            if gadgetnoise: 
                titlestring = titlestring + r"$\,\,|\,\,{\rm (gadget\, noise)}$"
            titlestring = r'$\eta = 0$'
            ax.set_title(titlestring)

### statistics in steady state / critical properties ### 
elif mode == "stats": 

    # reasonable guesses of critical exponents for 3-bit rep 
    nu = 1.26 
    gamma = 1.05 
    beta = .3
    # reasonable guesses for 5-bit 
    if "5bit" in model: 
        nu = 1.54
        pc = .014 # is this the same as the 3-bit case, wtf?
        gamma = 1.25

    nfs = len(fins)
    full_chis = np.zeros(nfs,dtype='object')
    full_ps = np.zeros(nfs,dtype='object')
    full_binds = np.zeros(nfs,dtype='object') 
    full_mags = np.zeros(nfs,dtype='object')
    full_signed_mags = np.zeros(nfs,dtype='object')
    full_Ts = np.zeros(nfs,dtype='object')
    full_ts = np.zeros(nfs,dtype='object')
    full_trels = np.zeros(nfs,dtype='object')
    Ls = np.zeros(nfs)

    for (f,fin) in enumerate(fins):
        data = loaddata(fin)
        L = data['L']
        mode = data["mode"]
        Ls[f] = L 
        bias = data['bias']
        ps = data['ps']
        try: 
            pc = data['pc']
        except: # default to the value for the 3-bit rep. code 
            pc = 0.0144 if bias == 0 else .006 
        pc = .0143 
        ts = (ps-pc)/pc

        full_mags[f] = (data["Ms"].T if bias != 0 else data["|M|s"].T) / L**dimension
        full_chis[f] = data["chis"].T 
        full_binds[f] = 3 * (1- data["binds"]/3)/2
        full_ts[f] = ts; full_ps[f] = ps 

    if not plot_thermo: 
        for (f,fin) in enumerate(fins): 
            col = cmap((f)/len(fins))
            ps = data[f]['ps'].T; nps = len(ps)
            L = data[f]['L']; l = data[f]['l']

            ## hamming weight statistics in the steady state 
            if args.plot_hamming: 
                ham_data = data['floquet_hamming_statistics'].T # nps x periods array of hamming weights collected after each period of the dynamics
                for i in range(1,nps+1):
                    p = ps[i-1]
                    this_ham_data = ham_data[i-1]
                    nbins = 500
                    counts,bins = np.histogram(this_ham_data,bins=nbins)

                    nonzero_indices = counts != 0
                    counts = counts[nonzero_indices]
                    bin_centers = (bins[:-1] + bins[1:]) / 2
                    bin_centers = bin_centers[nonzero_indices]

                    # make a pretty label for the current value of the noise 
                    thislab = f"{p:.1e}"
                    mantissa, exponent = thislab.split('e')
                    mantissa = float(mantissa) 
                    exponent = int(exponent) 
                    thislab = r"$%.1f \times 10^{%d}$"%(mantissa,exponent)

                    dx = bin_centers[1] - bin_centers[0]
                    ax.plot(bin_centers/L,counts / (np.sum(counts) * dx / L),c=cmap(i/nps),label=thislab)

                    ax.set(xlabel=r'$w/L$',ylabel=r'$f$')
                    ax.set_xlim(0,1)
                    ax.legend(title=r'$p$',framealpha=.95,frameon=True,loc='upper right')
                    ax.set_title(r'$L=3^{%d}$'%(l+1))

            ## correlation functions 
            elif args.plot_corrs: 
                # connected correlation functions determined from numerics: 
                corrs = data['corrs'].T # shape is (nps, T, L, L) where T is depth of one period  
                tcorrs = data['tcorrs'].T # shape is (nps, L, T, T) 

                # plot 2d images of correlation functions
                if args.corr_image_space or args.corr_image_time: 
                    if args.corr_image_space: 
                        image = ax.imshow(corrs[0,0,:,:].T,origin='lower')
                        lab = r'$C_{ij}$'
                    else: 
                        image = ax.imshow(corrs[0,int(round(L/2)),:,:].T,origin='lower')
                        lab = r'$C_{tt\'}$'
                    cbar = fig.colorbar(image,fraction=0.046, pad=0.04, ax = ax) 
                    cbar.minorticks_on()
                    cbar.set_label(lab)

                # make conventional plots 
                else: 
                    avg_hist = data['average_history'].T # averaged signed magnetization at each spacetime point (disconnected part has already been subtracted off)

                    floquet_corrs = (data['floquet_corrs'].T)

                    for (pind,p) in enumerate(ps): 
                        col = cmap((pind+1)/len(ps))
                        hL = int(round(L/2+.01))
                        oned_corrs = np.zeros((L,hL))
                        oned_floquet_corrs = np.zeros((L,hL))
                        for i in range(L): 
                            corrs[pind,i,i] += 1 # not exactly equal to 1 since the input data includes the subtraction by the disconnected part 
                            floquet_corrs[pind,i,i] += 1 
                        for i in range(L): 
                            for j in range(L): 
                                oned_corrs[i,circ_distance(i,j,L)] += corrs[pind,i,j] / (1 if i == j else 2) 
                                oned_floquet_corrs[i,circ_distance(i,j,L)] += floquet_corrs[pind,i,j] / (1 if i == j else 2)

                        avg_oned_corrs = np.mean(oned_corrs,axis=0)

                        ys = np.abs(avg_oned_corrs)
                        xs = np.linspace(1,hL,len(ys))
                        
                        polyfit = not args.expfit # if True, fits to polynomial function; if False, fits to exponential 
                        fits = np.polyfit(np.log(xs),np.log(ys),1) if polyfit else np.polyfit(xs,np.log(ys),1)

                        mp = int(round(len(xs)/4)) # point at which to match 
                        ax.plot(xs,ys,c=col)
                        if polyfit: 
                            ax.plot(xs,(xs/xs[mp])**(fits[0]) * ys[mp],ls='--',label=r'$%.3f,%.2f$'%(p,-fits[0]),c=col)
                        else: 
                            ax.plot(xs,np.exp((xs-xs[mp])*(fits[0])) * ys[mp],ls='--',label=r'$%.3f,%.2f$'%(p,-1/fits[0]),c=col)

                    if polyfit: 
                        if not args.change_xscale:
                            ax.set_xscale('log')  
                    if not args.change_yscale: 
                        ax.set_yscale('log')

                    ax.set(xlabel=r'$r$',ylabel=r'$C(r)$')
                    if polyfit: 
                        ax.legend(title=r'$\alpha$',title_fontsize=14)
                    else: 
                        ax.legend(title=r'$\xi$',title_fontsize=14)

            ## domain wall statistics (plots for different values of p at a single system size)
            elif args.dw_stats: 
                stats = data[f]['dw_stats'].T
                for i in range(nps): 
                    col = cmap((i+1)/nps)
                    ax.plot(L * stats[i] / np.sum(stats[i]),c=col,label=r'$%.3f$'%ps[i])
                ax.set(xlabel=r'$r$',ylabel=r'$g(r)$')
                ax.legend(title=r'$p$',title_fontsize=legend_title_fontsize,fontsize=legend_fontsize)
                if args.change_xscale: 
                    ax.set_xscale('log')
                if not args.change_yscale: 
                    ax.set_yscale('log')

    else: # plot thermodynamic quantities with the help of scaling_plotter.py: 
        thermo_data = dict()
        thermo_data["Ls"] = Ls; thermo_data["binds"] = full_binds; thermo_data["chis"] = full_chis; thermo_data["binds"] = full_binds; thermo_data["mags"] = full_mags; thermo_data["xs"] = full_ps

        titlestring = ""
        if model == "rep": 
            titlestring = r'${\rm rep.\, code}\,\,|\, \,\eta = %d$'%bias
        elif "5bit" in model: 
            titlestring = r'${\rm rep.\, code\,\, (5\,bit)}\,\,|\, \,\eta = %d$'%bias

        scaling_plotter(thermo_data,args.plt,pc,nu0=nu,gamma0=gamma,beta0=beta,raw=args.raw,d=dimension,title=titlestring)
        
if args.save != 'no':
    plt.savefig(args.save, bbox_inches='tight', pad_inches=0.1,facecolor='w',edgecolor='w',dpi=200)

plt.show()

